# 2.2. Thiết kế hệ thống (Co-op Survivors RL)

Mục tiêu: Thiết kế chi tiết bám sát kiến trúc phân lớp (Layered Architecture), Component-based (Unity), và MVC/MVVM cho UI đã lựa chọn ở Chương 1; làm rõ cách hình thành lớp, quan hệ, luồng dữ liệu giữa RL đa agent và gameplay co-op (multi-player), cùng các biểu đồ tuần tự cho từng use case trọng yếu.

## 2.2.1. Nguyên tắc thiết kế và ánh xạ kiến trúc

- Phân lớp 5 tầng: Presentation, Game Logic, AI & RL, Networking (tùy chọn), Data Persistence.
- Component-based: Hành vi gắn vào GameObject qua Component; các thành phần như `Monster`, `Player`, `RLMonster`, `RLEnvironment` là component.
- MVC/MVVM cho UI: View hiển thị; Controller/ViewModel xử lý tương tác và logic trình bày.
- Tách biệt rõ Boundary (lớp biên), Control (điều khiển), Entity (thực thể) trong mô hình phân tích/thiết kế.

## 2.2.2. Cơ sở hình thành lớp (phương pháp trích danh từ)

Áp dụng phương pháp trích danh từ từ yêu cầu (UC1–UC10) để xác định thực thể (Entity), biên (Boundary), điều khiển (Control):

- Thực thể (Entity) — các danh từ chính mô tả dữ liệu/đối tượng game:
  - Player, Monster, Environment, Reward, Experience, PolicyNetwork, Checkpoint, BehaviorProfile.
- Biên (Boundary) — các danh từ chỉ giao diện/tương tác:
  - GameUI, HUD, InputHandler, RLToolsUI.
- Điều khiển (Control) — các danh từ/động từ điều phối:
  - GameController, SpawnController, MonsterController, RLTrainingController, RLInferenceController, CheckpointController, MetricsController.

Kiểm tra quan hệ và lực lượng (multiplicity):

- Một `GameController` quản lý 1 `Environment`, 1 `Player`, và 0..\* `Monster`.
- `SpawnController` tạo 0..\* `Monster` theo thời gian.
- `RLInferenceController` sử dụng 1 `PolicyNetwork` để suy luận; `RLTrainingController` dùng 1 `Experience` buffer và cập nhật 1 `PolicyNetwork`.
- `CheckpointController` quản lý 0..\* `Checkpoint` phiên bản khác nhau.

## 2.2.3. Biểu đồ lớp (thiết kế) với stereotype và bội số

Hình 2.9: Class Diagram (Design) — Boundary, Control, Entity, với bội số và quan hệ đúng chuẩn UML.

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam classAttributeIconSize 0
skinparam stereotypeFontColor #444444

class GameUI <<boundary>> {
  + ShowHUD(): void
  + BindInputs(): void
}

class InputHandler <<boundary>> {
  + ReadInput(): InputEvent
}

class GameController <<control>> {
  + StartGame(): void
  + UpdateTick(): void
}

class SpawnController <<control>> {
  + ScheduleSpawns(): void
  + SpawnMonster(): Monster
}

class MonsterController <<control>> {
  + DecideAction(monster): void
}

class RLInferenceController <<control>> {
  + InferAction(obs): Action
}

class RLTrainingController <<control>> {
  + StoreTransition(t): void
  + TrainStep(): void
}

class CheckpointController <<control>> {
  + Save(model, metrics): void
  + Load(path): PolicyNetwork
}

class MetricsController <<control>> {
  + LogReward(r): void
  + LogLoss(l): void
}

class Player <<entity>> {
  + health: float
  + position: Vector2
}

class Monster <<entity>> {
  + type: MonsterType
  + health: float
}

class Environment <<entity>> {
  + time: float
  + obstacles: List
}

class Reward <<entity>> {
  + value: float
}

class Experience <<entity>> {
  + state: any
  + action: any
  + reward: float
  + nextState: any
  + done: bool
}

class PolicyNetwork <<entity>> {
  + Forward(obs): float[]
}

class Checkpoint <<entity>> {
  + version: string
}

class BehaviorProfile <<entity>> {
  + id: string
}

' Relationships with multiplicities
GameController "1" o-- "1" Environment : manages
GameController "1" o-- "1" Player : controls
GameController "1" o-- "0..*" Monster : controls
SpawnController "1" --> "0..*" Monster : creates
MonsterController "1" --> "0..*" Monster : orchestrates
RLInferenceController "1" --> "1" PolicyNetwork : uses
RLTrainingController "1" --> "1" PolicyNetwork : updates
RLTrainingController "1" --> "1" Experience : stores
CheckpointController "1" --> "0..*" Checkpoint : manages
MetricsController "1" --> "1" Reward : logs
GameUI "1" --> "1" InputHandler : reads
GameUI "1" --> "1" GameController : invokes

@enduml
```

Giải thích:

- Dùng `<<boundary>>`, `<<control>>`, `<<entity>>` để chỉ rõ vai trò lớp.
- Quan hệ và bội số (multiplicity) thể hiện thực tế thiết kế trong Unity.

## 2.2.4. RL ↔ Gameplay: Component & Data-Flow

Hình 2.10: Component Diagram — Luồng dữ liệu giữa module RL và gameplay.

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF

component "Gameplay Module" as GM {
  [GameController]
  [SpawnController]
  [MonsterController]
  [Environment]
  [Player]
}

component "RL Module" as RL {
  [RLEnvironment]
  [StateEncoder]
  [PolicyNetwork]
  [RLInferenceController]
  [RLTrainingController]
}

component "UI Module" as UI {
  [GameUI]
  [InputHandler]
}

component "Persistence" as P {
  [CheckpointController]
  [MetricsController]
}

UI --> GM : Input events
GM --> RL : Observations (state)
RL --> GM : Actions (decoded)
GM --> RL : Transitions (s,a,r,s')
RL --> P : Checkpoints, Metrics
P --> RL : Load model

note right of RL
  Data-flow:
  1) GM→RL: Encode state → obs
  2) RL: Policy forward → action
  3) RL→GM: Decode & execute
  4) GM→RL: Reward + store
  5) RL: Train & checkpoint
end note

@enduml
```

Luồng dữ liệu chi tiết:

- Gameplay gửi trạng thái (EntityManager/Environment) → RL (StateEncoder) để tạo observation.
- RL suy luận hành động qua PolicyNetwork → ActionDecoder → trả về MonsterController.
- Gameplay thực thi hành động, tính Reward → RLTrainingController lưu transition.
- RLTrainingController huấn luyện định kỳ và CheckpointController lưu mô hình.

## 2.2.5. Biểu đồ tuần tự (Sequence) theo kiến trúc — từng use case

Lưu ý: Các participant được gán stereotype phù hợp (boundary/control/entity) để bám đúng kiến trúc.

### Hình 2.11: UC1 — Bắt đầu màn chơi

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam actorStyle awesome
skinparam sequenceMessageAlign center

actor Player

participant MainMenuUI <<boundary>>
participant GameFlowController <<control>>
participant PlayerManager <<control>>
participant HUDController <<boundary>>
participant EnemyManager <<control>>
participant StateEncoder <<control>>
participant RLInferenceEngine <<entity>>
participant CheckpointRepo <<entity>>
participant GameState <<entity>>

== Khởi động phiên chơi ==
Player -> MainMenuUI: Chọn "Start Game"\n+ chọn nhân vật / co-op
MainMenuUI -> GameFlowController: StartGame(selectedCharacter, mode)
GameFlowController -> PlayerManager: CreatePlayers(count, layout)
GameFlowController -> HUDController: InitHUD(per player)
GameFlowController -> EnemyManager: InitEnemyPool()
GameFlowController -> GameState: SetState(Loading)

== Tải policy RL ==
GameFlowController -> CheckpointRepo: FetchLatestPolicy(onnx)
CheckpointRepo --> RLInferenceEngine: ONNX bytes
RLInferenceEngine --> GameFlowController: Policy loaded

== Chuẩn bị vòng lặp gameplay ==
GameFlowController -> StateEncoder: InitObservationSpace()
GameFlowController -> PlayerManager: SpawnPlayers(spawnPoints)
GameFlowController -> EnemyManager: SpawnWave0()
GameFlowController -> GameState: SetState(Playing)
HUDController -> Player: Hiển thị HUD ready
@enduml
```

### Hình 2.12: UC2 — Di chuyển nhân vật

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam actorStyle awesome
skinparam sequenceMessageAlign center

actor Player

participant InputHandler <<boundary>>
participant PlayerController <<control>>
participant Physics2D <<control>>
participant CombatSystem <<control>>
participant HUDView <<boundary>>
participant NetworkManager <<control>>
participant GameState <<entity>>
participant StateEncoder <<control>>
participant RLInferenceEngine <<entity>>
participant EnemyManager <<control>>

== Nhận input ==
Player -> InputHandler : Move / Attack input
InputHandler -> PlayerController : Dispatch input event

== Xử lý di chuyển ==
PlayerController -> Physics2D : Move(direction)
Physics2D --> PlayerController : New position / collisions
PlayerController -> GameState : Update player transform
PlayerController -> HUDView : Cập nhật HUD (pos/health)

== Auto-attack ==
PlayerController -> CombatSystem : Request auto-attack
CombatSystem -> EnemyManager : Query nearest enemy
CombatSystem -> GameState : Apply damage / spawn projectile
CombatSystem -> HUDView : Show hit / damage popup

== Đồng bộ Co-op (tùy chọn) ==
opt Online co-op
  PlayerController -> NetworkManager : Send state (pos/vel/action)
  NetworkManager --> PlayerController : Remote state (teammate)
end

== Cập nhật RL (liên kết gameplay ↔ RL) ==
GameState -> StateEncoder : Build observation (players, enemies, map)
StateEncoder -> RLInferenceEngine : Obs tensor
RLInferenceEngine --> EnemyManager : Actions (per enemy agent)
EnemyManager -> GameState : Apply enemy actions
EnemyManager -> HUDView : Update threat indicators

@enduml
```

### Hình 2.13: UC3 — Hợp tác Co-op

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam actorStyle awesome
skinparam sequenceMessageAlign center

actor "Player 1" as P1
actor "Player 2" as P2

participant InputHandler <<boundary>>
participant PlayerController <<control>>
participant ProximityService <<control>>
participant CombatSystem <<control>>
participant GameState <<entity>>
participant HUDView <<boundary>>
participant NetworkManager <<control>>

== Di chuyển & phát hiện phạm vi ==
P1 -> InputHandler : Move/Attack input
P2 -> InputHandler : Move/Attack input
InputHandler -> PlayerController : Dispatch inputs (P1,P2)
PlayerController -> ProximityService : CheckTeamRadius(P1,P2)
ProximityService --> PlayerController : inRadius?

alt Trong team radius
  PlayerController -> CombatSystem : ApplyTeamBonus(shared XP/loot)
  CombatSystem -> HUDView : Show "Team Bonus" popup
else Ngoài radius
  PlayerController -> CombatSystem : No bonus
end

== Giao tranh & chia sẻ XP ==
P1 -> CombatSystem : Attack enemy
CombatSystem -> GameState : Deal damage / kill
GameState -> CombatSystem : Enemy defeated
CombatSystem -> PlayerController : Shared XP (70% +10% bonus)
PlayerController -> HUDView : Popup "+Shared XP" P1 & P2

== Loot chia sẻ ==
GameState -> PlayerController : Drop loot
P2 -> PlayerController : Collect loot
PlayerController -> GameState : Split loot if teammate low HP
PlayerController -> HUDView : Update coin/gem both players

== Đồng bộ online (tùy chọn) ==
opt Online co-op
  PlayerController -> NetworkManager : Broadcast team state/bonuses
  NetworkManager --> PlayerController : Remote teammate state
end

@enduml
```

### Hình 2.14: UC4 — Suy luận hành động RL (Inference Runtime)

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam actorStyle awesome
skinparam sequenceMessageAlign center

actor "Enemy Tick" as Tick

participant EnemyManager <<control>>
participant GameState <<entity>>
participant StateEncoder <<control>>
participant RLInferenceEngine <<entity>>
participant PolicyNetwork <<entity>>
participant EnemyController <<control>>
participant HUDView <<boundary>>

== Lấy quan sát ==
Tick -> EnemyManager : For each agent: Request action
EnemyManager -> GameState : Read agent state + nearby players
GameState -> StateEncoder : Build observation vector
StateEncoder -> RLInferenceEngine : obs tensor

== Suy luận hành động ==
RLInferenceEngine -> PolicyNetwork : Forward(obs)
PolicyNetwork --> RLInferenceEngine : action logits
RLInferenceEngine --> EnemyManager : Decoded action

== Thực thi hành động ==
EnemyManager -> EnemyController : Execute(action)
EnemyController -> GameState : Update position/attack
EnemyController -> HUDView : Threat/attack indicator

== Ghi nhận (tùy chọn) ==
opt Training mode on
  EnemyController -> GameState : reward event
end

@enduml
```

### Hình 2.15: UC5 — Huấn luyện mô hình RL (Training Loop)

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam actorStyle awesome
skinparam sequenceMessageAlign center

actor Trainer

participant TrainingLoop <<control>>
participant RLEnvironment <<entity>>
participant StateEncoder <<control>>
participant PolicyNetwork <<entity>>
participant ReplayBuffer <<entity>>
participant RewardCalculator <<control>>
participant CheckpointRepo <<entity>>
participant MetricsLogger <<boundary>>

== Thu thập trajectory ==
Trainer -> TrainingLoop : Start run (config)
loop per step
  TrainingLoop -> RLEnvironment : Step()
  RLEnvironment --> TrainingLoop : state_t
  TrainingLoop -> StateEncoder : Encode(state_t)
  StateEncoder -> PolicyNetwork : Forward(obs)
  PolicyNetwork --> TrainingLoop : action_t
  TrainingLoop -> RLEnvironment : Apply(action_t)
  RLEnvironment --> TrainingLoop : state_{t+1}, done
  TrainingLoop -> RewardCalculator : CalcReward(s,a,s')
  RewardCalculator --> TrainingLoop : r_t
  TrainingLoop -> ReplayBuffer : Store(s, a, r, s', done)
end

== Optimize PPO/DQN ==
TrainingLoop -> ReplayBuffer : Sample(batch)
TrainingLoop -> PolicyNetwork : Backprop(batch)
TrainingLoop -> MetricsLogger : Log(loss, reward)

== Checkpoint định kỳ ==
opt every N steps
  TrainingLoop -> PolicyNetwork : Export ONNX
  PolicyNetwork --> CheckpointRepo : Save(ckpt)
end

@enduml
```

### Hình 2.17: UC9 — Lưu / tải model và checkpoint

```plantuml
@startuml
participant CheckpointController <<control>>
participant PolicyNetwork <<entity>>
participant MetricsController <<control>>
participant Checkpoint <<entity>>

CheckpointController -> PolicyNetwork: GetWeights()
CheckpointController -> MetricsController: GetMetrics()
CheckpointController -> Checkpoint: Save(weights, metrics)
CheckpointController -> PolicyNetwork: Load(path)
@enduml
```

### Hình 2.18: UC10 — Theo dõi hiệu năng & debug AI

```plantuml
@startuml
participant MetricsController <<control>>
participant Reward <<entity>>
participant PolicyNetwork <<entity>>
participant RLTrainingController <<control>>

RLTrainingController -> Reward: Compute()
MetricsController -> Reward: LogReward()
MetricsController -> PolicyNetwork: LogLoss()
@enduml
```

## 2.2.6. Kết nối logic và tổ chức báo cáo

- Phần 2.2 tổ chức theo: (1) nguyên tắc thiết kế; (2) hình thành lớp; (3) biểu đồ lớp; (4) luồng dữ liệu RL↔Gameplay; (5) biểu đồ tuần tự cho từng use case.
- Tất cả tên lớp, module, use case khớp với phần 2.1.
- Quan hệ UML dùng đúng ký hiệu: association, composition (o--), dependency (-->), multiplicity (1, 0.._, 1.._).
- Các stereotype `<<boundary>>`, `<<control>>`, `<<entity>>` được áp dụng xuyên suốt để phản ánh kiến trúc.
