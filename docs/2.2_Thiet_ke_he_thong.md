# 2.2. Thiết kế hệ thống

Mục tiêu: Thiết kế chi tiết bám sát kiến trúc phân lớp (Layered Architecture), Component-based (Unity), và MVC/MVVM cho UI đã lựa chọn ở Chương 1; làm rõ cách hình thành lớp, quan hệ, luồng dữ liệu giữa RL và gameplay, cùng các biểu đồ tuần tự cho từng use case trọng yếu.

## 2.2.1. Nguyên tắc thiết kế và ánh xạ kiến trúc

- Phân lớp 5 tầng: Presentation, Game Logic, AI & RL, Networking (tùy chọn), Data Persistence.
- Component-based: Hành vi gắn vào GameObject qua Component; các thành phần như `Monster`, `Player`, `RLMonster`, `RLEnvironment` là component.
- MVC/MVVM cho UI: View hiển thị; Controller/ViewModel xử lý tương tác và logic trình bày.
- Tách biệt rõ Boundary (lớp biên), Control (điều khiển), Entity (thực thể) trong mô hình phân tích/thiết kế.

## 2.2.2. Cơ sở hình thành lớp (phương pháp trích danh từ)

Áp dụng phương pháp trích danh từ từ yêu cầu (UC1–UC10) để xác định thực thể (Entity), biên (Boundary), điều khiển (Control):

- Thực thể (Entity) — các danh từ chính mô tả dữ liệu/đối tượng game:
  - Player, Monster, Environment, Reward, Experience, PolicyNetwork, Checkpoint, BehaviorProfile.
- Biên (Boundary) — các danh từ chỉ giao diện/tương tác:
  - GameUI, HUD, InputHandler, RLToolsUI.
- Điều khiển (Control) — các danh từ/động từ điều phối:
  - GameController, SpawnController, MonsterController, RLTrainingController, RLInferenceController, CheckpointController, MetricsController.

Kiểm tra quan hệ và lực lượng (multiplicity):

- Một `GameController` quản lý 1 `Environment`, 1 `Player`, và 0..\* `Monster`.
- `SpawnController` tạo 0..\* `Monster` theo thời gian.
- `RLInferenceController` sử dụng 1 `PolicyNetwork` để suy luận; `RLTrainingController` dùng 1 `Experience` buffer và cập nhật 1 `PolicyNetwork`.
- `CheckpointController` quản lý 0..\* `Checkpoint` phiên bản khác nhau.

## 2.2.3. Biểu đồ lớp (thiết kế) với stereotype và bội số

Hình 2.9: Class Diagram (Design) — Boundary, Control, Entity, với bội số và quan hệ đúng chuẩn UML.

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF
skinparam classAttributeIconSize 0
skinparam stereotypeFontColor #444444

class GameUI <<boundary>> {
  + ShowHUD(): void
  + BindInputs(): void
}

class InputHandler <<boundary>> {
  + ReadInput(): InputEvent
}

class GameController <<control>> {
  + StartGame(): void
  + UpdateTick(): void
}

class SpawnController <<control>> {
  + ScheduleSpawns(): void
  + SpawnMonster(): Monster
}

class MonsterController <<control>> {
  + DecideAction(monster): void
}

class RLInferenceController <<control>> {
  + InferAction(obs): Action
}

class RLTrainingController <<control>> {
  + StoreTransition(t): void
  + TrainStep(): void
}

class CheckpointController <<control>> {
  + Save(model, metrics): void
  + Load(path): PolicyNetwork
}

class MetricsController <<control>> {
  + LogReward(r): void
  + LogLoss(l): void
}

class Player <<entity>> {
  + health: float
  + position: Vector2
}

class Monster <<entity>> {
  + type: MonsterType
  + health: float
}

class Environment <<entity>> {
  + time: float
  + obstacles: List
}

class Reward <<entity>> {
  + value: float
}

class Experience <<entity>> {
  + state: any
  + action: any
  + reward: float
  + nextState: any
  + done: bool
}

class PolicyNetwork <<entity>> {
  + Forward(obs): float[]
}

class Checkpoint <<entity>> {
  + version: string
}

class BehaviorProfile <<entity>> {
  + id: string
}

' Relationships with multiplicities
GameController "1" o-- "1" Environment : manages
GameController "1" o-- "1" Player : controls
GameController "1" o-- "0..*" Monster : controls
SpawnController "1" --> "0..*" Monster : creates
MonsterController "1" --> "0..*" Monster : orchestrates
RLInferenceController "1" --> "1" PolicyNetwork : uses
RLTrainingController "1" --> "1" PolicyNetwork : updates
RLTrainingController "1" --> "1" Experience : stores
CheckpointController "1" --> "0..*" Checkpoint : manages
MetricsController "1" --> "1" Reward : logs
GameUI "1" --> "1" InputHandler : reads
GameUI "1" --> "1" GameController : invokes

@enduml
```

Giải thích:

- Dùng `<<boundary>>`, `<<control>>`, `<<entity>>` để chỉ rõ vai trò lớp.
- Quan hệ và bội số (multiplicity) thể hiện thực tế thiết kế trong Unity.

## 2.2.4. RL ↔ Gameplay: Component & Data-Flow

Hình 2.10: Component Diagram — Luồng dữ liệu giữa module RL và gameplay.

```plantuml
@startuml
!theme plain
skinparam backgroundColor #FFFFFF

component "Gameplay Module" as GM {
  [GameController]
  [SpawnController]
  [MonsterController]
  [Environment]
  [Player]
}

component "RL Module" as RL {
  [RLEnvironment]
  [StateEncoder]
  [PolicyNetwork]
  [RLInferenceController]
  [RLTrainingController]
}

component "UI Module" as UI {
  [GameUI]
  [InputHandler]
}

component "Persistence" as P {
  [CheckpointController]
  [MetricsController]
}

UI --> GM : Input events
GM --> RL : Observations (state)
RL --> GM : Actions (decoded)
GM --> RL : Transitions (s,a,r,s')
RL --> P : Checkpoints, Metrics
P --> RL : Load model

note right of RL
  Data-flow:
  1) GM→RL: Encode state → obs
  2) RL: Policy forward → action
  3) RL→GM: Decode & execute
  4) GM→RL: Reward + store
  5) RL: Train & checkpoint
end note

@enduml
```

Luồng dữ liệu chi tiết:

- Gameplay gửi trạng thái (EntityManager/Environment) → RL (StateEncoder) để tạo observation.
- RL suy luận hành động qua PolicyNetwork → ActionDecoder → trả về MonsterController.
- Gameplay thực thi hành động, tính Reward → RLTrainingController lưu transition.
- RLTrainingController huấn luyện định kỳ và CheckpointController lưu mô hình.

## 2.2.5. Biểu đồ tuần tự (Sequence) theo kiến trúc — từng use case

Lưu ý: Các participant được gán stereotype phù hợp (boundary/control/entity) để bám đúng kiến trúc.

### Hình 2.11: UC1 — Bắt đầu màn chơi

```plantuml
@startuml
actor Player
participant GameUI <<boundary>>
participant GameController <<control>>
participant Environment <<entity>>
participant SpawnController <<control>>
participant Player <<entity>>

Player -> GameUI: Press "Start"
GameUI -> GameController: StartGame()
GameController -> Environment: Reset()
GameController -> Player: Init()
GameController -> SpawnController: ScheduleSpawns()
@enduml
```

### Hình 2.12: UC2 — Di chuyển nhân vật

```plantuml
@startuml
actor Player
participant InputHandler <<boundary>>
participant GameController <<control>>
participant Player <<entity>>

Player -> InputHandler: Move input
InputHandler -> GameController: InputEvent
GameController -> Player: Move(direction)
@enduml
```

### Hình 2.13: UC3 — Spawn quái vật động

```plantuml
@startuml
participant GameController <<control>>
participant SpawnController <<control>>
participant Monster <<entity>>

GameController -> SpawnController: Tick()
SpawnController -> SpawnController: EvaluateSchedule()
SpawnController -> Monster: SpawnMonster()
@enduml
```

### Hình 2.14: UC4 — Hành vi quái vật (kết nối RL)

```plantuml
@startuml
participant MonsterController <<control>>
participant RLInferenceController <<control>>
participant RLEnvironment <<entity>>
participant StateEncoder <<entity>>
participant PolicyNetwork <<entity>>
participant Monster <<entity>>

MonsterController -> RLEnvironment: GetState(monster)
RLEnvironment -> StateEncoder: Encode(state)
StateEncoder --> RLEnvironment: obs
RLEnvironment --> RLInferenceController: obs
RLInferenceController -> PolicyNetwork: Forward(obs)
PolicyNetwork --> RLInferenceController: action
RLInferenceController --> MonsterController: decoded action
MonsterController -> Monster: Execute(action)
@enduml
```

### Hình 2.15: UC7 — Huấn luyện mô hình (Training Mode)

```plantuml
@startuml
participant RLTrainingController <<control>>
participant RLEnvironment <<entity>>
participant PolicyNetwork <<entity>>
participant Experience <<entity>>
participant Reward <<entity>>

RLTrainingController -> RLEnvironment: Observe()
RLEnvironment --> RLTrainingController: obs
RLTrainingController -> PolicyNetwork: Forward(obs)
PolicyNetwork --> RLTrainingController: action
RLTrainingController -> RLEnvironment: Step(action)
RLEnvironment --> RLTrainingController: next state
RLTrainingController -> Reward: Calculate()
RLTrainingController -> Experience: Store(s,a,r,s',done)
RLTrainingController -> PolicyNetwork: TrainStep(batch)
@enduml
```

### Hình 2.16: UC8 — Suy luận hành động (Inference Mode)

```plantuml
@startuml
participant MonsterController <<control>>
participant RLInferenceController <<control>>
participant RLEnvironment <<entity>>
participant StateEncoder <<entity>>
participant PolicyNetwork <<entity>>
participant Monster <<entity>>

MonsterController -> RLEnvironment: GetState(monster)
RLEnvironment -> StateEncoder: Encode()
StateEncoder --> RLInferenceController: obs
RLInferenceController -> PolicyNetwork: Forward(obs)
PolicyNetwork --> RLInferenceController: action
RLInferenceController --> MonsterController: decoded action
MonsterController -> Monster: Execute(action)
@enduml
```

### Hình 2.17: UC9 — Lưu / tải model và checkpoint

```plantuml
@startuml
participant CheckpointController <<control>>
participant PolicyNetwork <<entity>>
participant MetricsController <<control>>
participant Checkpoint <<entity>>

CheckpointController -> PolicyNetwork: GetWeights()
CheckpointController -> MetricsController: GetMetrics()
CheckpointController -> Checkpoint: Save(weights, metrics)
CheckpointController -> PolicyNetwork: Load(path)
@enduml
```

### Hình 2.18: UC10 — Theo dõi hiệu năng & debug AI

```plantuml
@startuml
participant MetricsController <<control>>
participant Reward <<entity>>
participant PolicyNetwork <<entity>>
participant RLTrainingController <<control>>

RLTrainingController -> Reward: Compute()
MetricsController -> Reward: LogReward()
MetricsController -> PolicyNetwork: LogLoss()
@enduml
```

## 2.2.6. Kết nối logic và tổ chức báo cáo

- Phần 2.2 tổ chức theo: (1) nguyên tắc thiết kế; (2) hình thành lớp; (3) biểu đồ lớp; (4) luồng dữ liệu RL↔Gameplay; (5) biểu đồ tuần tự cho từng use case.
- Tất cả tên lớp, module, use case khớp với phần 2.1.
- Quan hệ UML dùng đúng ký hiệu: association, composition (o--), dependency (-->), multiplicity (1, 0.._, 1.._).
- Các stereotype `<<boundary>>`, `<<control>>`, `<<entity>>` được áp dụng xuyên suốt để phản ánh kiến trúc.
