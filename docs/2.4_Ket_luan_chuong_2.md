# 2.4. Kết luận Chương 2

Chương 2 đã hoàn tất việc đặc tả thiết kế cốt lõi cho hệ thống theo kiến trúc phân lớp, định hướng thành phần (Unity) và mô hình MVC/MVVM cho UI, đồng thời làm rõ cơ chế tích hợp RL với gameplay.

Tổng hợp nội dung chính:

- Kiến trúc & nguyên tắc: 5 tầng (Presentation, Game Logic, AI & RL, Networking, Data Persistence), phân định rõ Boundary/Control/Entity giúp mã nguồn dễ kiểm thử và mở rộng.
- Biểu đồ lớp & use case: Class Diagram chỉ ra vai trò và quan hệ với bội số; các biểu đồ tuần tự (UC1, UC2, UC3, UC4, UC7, UC8, UC9, UC10) mô tả luồng tương tác chi tiết giữa UI, gameplay và RL trong cả chế độ suy luận và huấn luyện.
- RL ↔ Gameplay: Định nghĩa rõ luồng dữ liệu qua `RLEnvironment`/`StateEncoder`/`PolicyNetwork`, cơ chế nhận obs → hành động → thực thi → tính thưởng → lưu kinh nghiệm.
- Cơ sở dữ liệu: Phân tách dữ liệu game (telemetry, match log) và dữ liệu RL (experience, metrics, checkpoint). ERD bao gồm các thực thể như `TrainingRun`, `RLExperience`, `StateSnapshot`, `Checkpoint`, `BehaviorProfile`, `InferenceLog`, kèm hướng dẫn lưu trữ (SQL + blob) và chỉ mục truy vấn.

Lợi ích thiết kế:

- Khả mở rộng: Tách lớp/biên rõ ràng giúp thay thế thuật toán RL hoặc mở rộng quái/vũ khí mà không ảnh hưởng rộng.
- Khả quan sát & tái lập: Log phiên, experience, checkpoint phiên bản hóa, giúp so sánh mô hình và tái hiện thí nghiệm.
- Dễ kiểm thử: Control tách rời Entity/UI, thuận lợi cho unit/integration test.

Rủi ro & cách giảm thiểu:

- Độ trễ suy luận: dùng encoder nhẹ, batch/tối ưu hóa model (ONNX/Burst/Jobs), cơ chế degrade/fallback khi quá tải.
- Kích thước trạng thái/nhật ký: chuẩn hóa đặc trưng, nén snapshot, TTL/archiving cho bảng chi tiết (experience, events).
- Đồng bộ phiên bản: gắn `env_version/build_version`, schema versioning cho dữ liệu và checkpoint.
- Tính nhất quán chỉ mục: thiết lập index (ví dụ: `(session_id, tick)`, `(run_id, step)`, `(run_id, version)`) và kiểm soát luồng ghi.

Định hướng Chương 3 — Thử nghiệm và đánh giá game sinh tồn:

- Triển khai thành phần gameplay và controller: `GameController`, `SpawnController`, `MonsterController`, `InputHandler`, `GameUI`.
- Tích hợp RL: `RLEnvironment`, `StateEncoder`, `RLInferenceController`, `RLTrainingController`, pipeline lưu `Experience` và checkpoint.
- Tầng dữ liệu: adapter ghi `SessionEvent/MatchSummary`, ghi `TrainingRun/LossLog/RewardLog`, quản lý `Checkpoint/BehaviorProfile`.
- Kiểm thử & đo lường: bộ test cho controller/encoder, benchmark độ trễ inference, dashboard metrics (reward, loss, fps, latency).
- Tự động hóa: script huấn luyện, đánh giá, và so sánh model theo `run_id`.

Kết luận: Thiết kế ở Chương 2 đủ chi tiết để bắt đầu cài đặt module, kết nối RL vào gameplay, và xây dựng pipeline dữ liệu–huấn luyện–đánh giá một cách lặp lại, có thể đo lường và mở rộng.
